//////////////////////////////////////////////////////////////////////
///Function to monitor pop up windows (e.g. Eclipse warning after dose calc)
///and close the windows//
/// Include functions:
///     CloseWarningThread - main routine to monitor open processes and close the process if it has a "warning" or "OK" text
///     GetOpenWindows - function to get all open processes
///     GetOpenChildWindows - function to get all text on the selected process window
///     Close - close the selected process
///
///--version 2.0.0.1
///Becket Hui 2024/7
///--version 1.0.1.1
///Becket Hui 2022/9
///
//////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using HWND = System.IntPtr;

namespace batchOptimization
{
    internal class CloseWindow
    {
        public Task CloseWarningThread(CancellationToken token)
        // Running Task that closes warning windows generated by Esapi
        {
            int currPid = Process.GetCurrentProcess().Id;  // pid of the current application
            return Task.Run(async () =>
            {
                while (!token.IsCancellationRequested)
                {
                    foreach (KeyValuePair<HWND, string> processApp in GetOpenWindows())  // get pid of all open apps
                    {
                        UInt32 pid;
                        GetWindowThreadProcessId(processApp.Key, out pid);
                        if (pid == currPid)  // pid of the open app matches the pid of the current application
                        {
                            foreach (KeyValuePair<HWND, string> widgetText in GetOpenChildWindows(processApp.Key))
                            {
                                if (widgetText.Value.Contains("Warning:") || widgetText.Value.Contains("OK"))  // if the window text contains Warning: or OK button 
                                {
                                    Close(processApp.Key);
                                    break;
                                }
                            }
                        }
                    }
                    await Task.Delay(10000, token);  // wait for 10 sec
                }
            }, token);
        }
        // user32 functions //
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out UInt32 processId);
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern uint FindWindow(string className, string processId);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr GetShellWindow();
        private delegate bool EnumWindowsProc(HWND hWnd, int lParam);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern bool EnumWindows(EnumWindowsProc enumFunc, int lParam);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern bool IsWindowVisible(HWND hWnd);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern int GetWindowTextLength(HWND hWnd);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern int GetWindowText(HWND hWnd, StringBuilder lpString, int nMaxCount);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern bool EnumChildWindows(HWND ptr, EnumWindowsProc enumFunc, int lParam);
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr lParam);
        public static IDictionary<HWND, string> GetOpenWindows()
        // Get open apps info //
        {
            HWND shellWindow = GetShellWindow();
            Dictionary<HWND, string> windows = new Dictionary<HWND, string>();
            UInt32 pid;

            EnumWindows(delegate (HWND hWnd, int lParam)
            {
                if (hWnd == shellWindow) return true;
                if (!IsWindowVisible(hWnd)) return true;

                int length = GetWindowTextLength(hWnd);

                StringBuilder builder = new StringBuilder(length);
                GetWindowText(hWnd, builder, length + 1);

                GetWindowThreadProcessId(hWnd, out pid);

                windows[hWnd] = builder.ToString();
                return true;
            }, 0);

            return windows;
        }
        public static IDictionary<HWND, string> GetOpenChildWindows(HWND ptr)
        // Get text within the selected window //
        {
            HWND shellWindow = GetShellWindow();
            Dictionary<HWND, string> windows = new Dictionary<HWND, string>();
            UInt32 pid;

            EnumChildWindows(ptr, delegate (HWND hWnd, int lParam)
            {
                if (hWnd == shellWindow) return true;
                if (!IsWindowVisible(hWnd)) return true;

                int length = GetWindowTextLength(hWnd);

                StringBuilder builder = new StringBuilder(length);
                GetWindowText(hWnd, builder, length + 1);

                GetWindowThreadProcessId(hWnd, out pid);

                windows[hWnd] = builder.ToString();
                return true;
            }, 0);

            return windows;
        }
        public static void Close(IntPtr hwnd)
        // Close the selected window //
        {
            UInt32 WM_Close = 0x0010;
            SendMessage(hwnd, WM_Close, IntPtr.Zero, IntPtr.Zero);
        }
    }
}
